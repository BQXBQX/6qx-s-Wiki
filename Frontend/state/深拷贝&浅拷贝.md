---
title: 深拷贝&浅拷贝
description: 
published: true
date: 2024-02-18T14:17:27.819Z
tags: frontend, state, 拷贝
editor: markdown
dateCreated: 2024-02-18T14:16:29.130Z
---

# 深拷贝&浅拷贝
## 介绍
### 浅拷贝
```
var m = { a: 10, b: 20 }
var n = m; 
n.a = 15; // 这时m.a的值是多少
```
m.a会输出15，因为这是浅拷贝，n和m指向的是同一个堆，对象复制只是复制的对象的引用。
### 深拷贝
```
var m = { a: 10, b: 20 } 
var n = {a:m.a,b:m.b}; 
n.a = 15;
```
深拷贝和上面浅拷贝不同，就是彻底copy一个对象，而不是copy对象的引用。
这次，我们再来输出m.a ，发现m.a的值还是10,并没有改变，m对象和n对象是虽然所有的值都是一样的，但是在堆里面，对应的不是同一个了，这个就是深拷贝。
### 示意图
![bvco56q.webp](/public/bvco56q.webp)
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 浅拷贝的实现方式
### 1. 赋值
### 2. Object.assign()实现

Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。
```
var obj = { a: {a: "hello", b: 21} };
var initalObj = Object.assign({}, obj);
initalObj.a.a = "changed";
console.log(obj.a.a); //  "changed"
```
注意：当object只有一层的时候，是深拷贝，例如如下：
```
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = Object.assign({}, obj1);
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 20, c: 30 } <-- 沒被改到
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```
### 3. 函数库lodash的_.clone方法
该函数库也有提供_.clone用来做 Shallow Copy,后面我们会再介绍利用这个库实现深拷贝。

```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.clone(obj1);
console.log(obj1.b.f === obj2.b.f);// true

```
### 4. 展开运算符...
展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。
也是当object只有一层的时候，是深拷贝，例如如下：
```
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```
### 5. Array.prototype.concat()
```
let arr = [1, 3, { username: 'kobe' }];
let arr2 = arr.concat();    
arr2[2].username = 'wade';
console.log(arr); //[ 1, 3, { username: 'wade' } ]
```




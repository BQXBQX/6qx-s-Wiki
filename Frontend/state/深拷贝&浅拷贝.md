---
title: 深拷贝&浅拷贝
description: 
published: true
date: 2024-02-18T14:24:41.309Z
tags: frontend, state, 拷贝
editor: markdown
dateCreated: 2024-02-18T14:16:29.130Z
---

# 深拷贝&浅拷贝
## 介绍
### 浅拷贝
```
var m = { a: 10, b: 20 }
var n = m; 
n.a = 15; // 这时m.a的值是多少
```
m.a会输出15，因为这是浅拷贝，n和m指向的是同一个堆，对象复制只是复制的对象的引用。
### 深拷贝
```
var m = { a: 10, b: 20 } 
var n = {a:m.a,b:m.b}; 
n.a = 15;
```
深拷贝和上面浅拷贝不同，就是彻底copy一个对象，而不是copy对象的引用。
这次，我们再来输出m.a ，发现m.a的值还是10,并没有改变，m对象和n对象是虽然所有的值都是一样的，但是在堆里面，对应的不是同一个了，这个就是深拷贝。
### 示意图
![bvco56q.webp](/public/bvco56q.webp)
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 浅拷贝的实现方式
### 1. 赋值
### 2. Object.assign()实现

Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。
```
var obj = { a: {a: "hello", b: 21} };
var initalObj = Object.assign({}, obj);
initalObj.a.a = "changed";
console.log(obj.a.a); //  "changed"
```
注意：当object只有一层的时候，是深拷贝，例如如下：
```
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = Object.assign({}, obj1);
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 20, c: 30 } <-- 沒被改到
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```
### 3. 函数库lodash的_.clone方法
该函数库也有提供_.clone用来做 Shallow Copy,后面我们会再介绍利用这个库实现深拷贝。

```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.clone(obj1);
console.log(obj1.b.f === obj2.b.f);// true

```
### 4. 展开运算符...
展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。
也是当object只有一层的时候，是深拷贝，例如如下：
```
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```
### 5. Array.prototype.concat()
```
let arr = [1, 3, { username: 'kobe' }];
let arr2 = arr.concat();    
arr2[2].username = 'wade';
console.log(arr); //[ 1, 3, { username: 'wade' } ]
```
### 6. Array.prototype.slice()
```
let arr = [1, 3, { username: ' kobe' }];
let arr3 = arr.slice();
arr3[2].username = 'wade'
console.log(arr); // [ 1, 3, { username: 'wade' } ]
```
#### slice() 和 concat() 是 JavaScript 数组的两个常用方法，它们有以下区别：

slice() 方法是用于创建一个新数组，包含原数组中的一部分元素。它接受两个参数，即起始索引和结束索引（可选）。slice() 方法返回从起始索引到结束索引（不包括结束索引）之间的元素组成的新数组。原始数组不会被修改。

语法：array.slice(startIndex, endIndex)
示例：

```
const array = [1, 2, 3, 4, 5];
const newArray = array.slice(1, 4);
console.log(newArray); // [2, 3, 4]
console.log(array); // [1, 2, 3, 4, 5]
```
concat() 方法用于将两个或多个数组合并成一个新数组。它不会修改原始数组，而是返回一个新数组。concat() 方法接受一个或多个参数，每个参数可以是数组或者值。它会按照参数在方法调用中的顺序，依次将它们连接起来形成一个新数组。

语法：array.concat(array1, array2, ..., arrayN)
示例：

```
const array1 = [1, 2];
const array2 = [3, 4];
const newArray = array1.concat(array2);
console.log(newArray); // [1, 2, 3, 4]
console.log(array1); // [1, 2]
console.log(array2); // [3, 4]
```
需要注意的是，slice() 和 concat() 方法都返回新数组，而不会修改原始数组。另外，它们都不会深拷贝数组中的对象，只会复制对象的引用。如果原始数组包含对象或其他引用类型的元素，那么操作后的新数组中的相应元素仍然引用同一个对象。

综上所述，slice() 是从原数组中提取一部分元素创建新数组，而 concat() 是将多个数组合并成一个新数组。

## 深拷贝
### 1. 赋值
### 2. 对象只有一层的话可以使用上面的：Object.assign()函数

### 3. 转成 JSON 再转回来
```
var obj1 = { body: { a: 10 } };
var obj2 = JSON.parse(JSON.stringify(obj1));
obj2.body.a = 20;
console.log(obj1);
// { body: { a: 10 } } <-- 沒被改到
console.log(obj2);
// { body: { a: 20 } }
console.log(obj1 === obj2);
// false
console.log(obj1.body === obj2.body);
// false
```
用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。

可以封装如下函数
```
var cloneObj = function(obj){
    var str, newobj = obj.constructor === Array ? [] : {};
    if(typeof obj !== 'object'){
        return;
    } else if(window.JSON){
        str = JSON.stringify(obj), //系列化对象
        newobj = JSON.parse(str); //还原
    } else {
        for(var i in obj){
            newobj[i] = typeof obj[i] === 'object' ? 
            cloneObj(obj[i]) : obj[i]; 
        }
    }
    return newobj;
};
```
### 4. 函数库lodash的_.cloneDeep方法

该函数库也有提供_.cloneDeep用来做 Deep Copy
```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```
### 5. 递归拷贝
```
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }        
    if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : {};            
      arguments.callee(prop, obj[i]);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
var str = {};
var obj = { a: {a: "hello", b: 21} };
deepClone(obj, str);
console.log(str.a);
```
### 6. 使用Object.create()方法

直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。
```
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }        
    if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
```
### 7. lodash

另外一个很热门的函数库lodash，也有提供_.cloneDeep用来做 Deep Copy。
```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);
// false
```